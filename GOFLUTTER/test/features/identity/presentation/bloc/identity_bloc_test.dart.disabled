import 'package:flutter_test/flutter_test.dart';
import 'package:mockito/mockito.dart';
import 'package:bloc_test/bloc_test.dart';
import 'package:atlas_blockchain_flutter/features/identity/presentation/bloc/identity_bloc.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/user_profile_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/kyc_status_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/privacy_settings_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/verification_option_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/activity_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/reputation_data_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/data/models/activity_metrics_model.dart';
import 'package:atlas_blockchain_flutter/features/identity/domain/repositories/identity_repository.dart';

class MockIdentityRepository extends Mock implements IdentityRepository {}

void main() {
  group('IdentityBloc', () {
    late IdentityBloc identityBloc;
    late MockIdentityRepository mockRepository;

    setUp(() {
      mockRepository = MockIdentityRepository();
      identityBloc = IdentityBloc(identityRepository: mockRepository);
    });

    tearDown(() {
      identityBloc.close();
    });

    test('initial state is IdentityInitial', () {
      expect(identityBloc.state, equals(IdentityInitial()));
    });

    blocTest<IdentityBloc, IdentityState>(
      'emits [IdentityLoading, IdentityLoaded] when LoadIdentityData is added and succeeds',
      build: () {
        final userProfile = UserProfileModel(
          username: 'testuser',
          fullName: 'Test User',
          email: 'test@example.com',
          bio: 'A test user',
          location: 'Test Location',
          website: 'https://example.com',
          socialLinks: {},
          status: 'active',
          verificationLevel: 'Level 1',
        );
        
        final kycStatus = KycStatusModel(
          level: 'Level 1',
          isVerified: true,
          lastUpdated: DateTime.now(),
        );
        
        final privacySettings = PrivacySettingsModel(
          profileVisibility: true,
          activityVisibility: true,
          allowDirectMessages: true,
          showOnlineStatus: true,
          dataSharing: false,
          analyticsTracking: false,
          marketingEmails: false,
          thirdPartySharing: false,
        );
        
        final verificationOptions = <VerificationOptionModel>[];
        final activityHistory = <ActivityModel>[];
        final reputationData = ReputationDataModel(score: 85.5, level: 'Good');
        final activityMetrics = ActivityMetricsModel(
          totalActivities: 100,
          weeklyChange: 5.0,
          monthlyTrend: [10, 15, 20, 25, 30],
        );
        
        when(mockRepository.getUserProfile()).thenAnswer((_) async => userProfile);
        when(mockRepository.getKycStatus()).thenAnswer((_) async => kycStatus);
        when(mockRepository.getPrivacySettings()).thenAnswer((_) async => privacySettings);
        when(mockRepository.getVerificationOptions()).thenAnswer((_) async => verificationOptions);
        when(mockRepository.getActivityHistory()).thenAnswer((_) async => activityHistory);
        when(mockRepository.getReputationData()).thenAnswer((_) async => reputationData);
        when(mockRepository.getActivityMetrics()).thenAnswer((_) async => activityMetrics);
        
        return identityBloc;
      },
      act: (bloc) => bloc.add(LoadIdentityData()),
      expect: (bloc) => [
        isA<IdentityLoading>(),
        isA<IdentityLoaded>(),
      ],
    );
  });
}